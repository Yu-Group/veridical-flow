<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vflow.convert API documentation</title>
<meta name="description" content="Useful functions for converting between different types (dicts, lists, tuples, etc.)" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vflow.convert</code></h1>
</header>
<section id="section-intro">
<p>Useful functions for converting between different types (dicts, lists, tuples, etc.)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Useful functions for converting between different types (dicts, lists, tuples, etc.)
&#34;&#34;&#34;
from copy import deepcopy
from typing import Union
from uuid import uuid4

import pandas as pd
from pandas import DataFrame

from vflow.subkey import Subkey
from vflow.vfunc import VfuncPromise
from vflow.vset import PREV_KEY


def init_args(args_tuple: Union[tuple, list], names=None):
    &#34;&#34;&#34; converts tuple of arguments to a list of dicts
    Params
    ------
    names: optional, list-like
        gives names for each of the arguments in the tuple
    &#34;&#34;&#34;
    if names is None:
        names = [&#39;start&#39;] * len(args_tuple)
    else:
        assert len(names) == len(args_tuple), &#39;names should be same length as args_tuple&#39;

    output_dicts = []
    for (i, ele) in enumerate(args_tuple):
        output_dicts.append({
            (Subkey(names[i], &#39;init&#39;),): args_tuple[i],
            PREV_KEY: (&#39;init&#39;,),
        })
    return output_dicts


def s(x):
    &#34;&#34;&#34;Gets shape of a list/tuple/ndarray
    &#34;&#34;&#34;
    if type(x) in [list, tuple]:
        return len(x)
    else:
        return x.shape


def init_step(idx, cols):
    for i in range(idx, len(cols)):
        if cols[i] != &#39;init&#39;:
            return &#39;init-&#39; + cols[i]


def dict_to_df(d: dict, param_key=None):
    &#34;&#34;&#34;Converts a dictionary with tuple keys
    into a pandas DataFrame, optionally seperating
    parameters in param_key if not None
    &#34;&#34;&#34;
    d_copy = {tuple([sk.value for sk in k]): d[k] for k in d if k != PREV_KEY}
    df = pd.Series(d_copy).reset_index()
    if len(d_copy.keys()) &gt; 0:
        key_list = list(d.keys())
        subkey_list = key_list[0] if key_list[0] != PREV_KEY else key_list[1]
        cols = [sk.origin for sk in subkey_list] + [&#39;out&#39;]
        # set each init col to init-{next_module_set}
        cols = [c if c != &#39;init&#39; else init_step(idx, cols) for idx, c in enumerate(cols)]
        df.set_axis(cols, axis=1, inplace=True)
        if param_key:
            df = df.join(pd.DataFrame(df[param_key].tolist()))
    return df


def compute_interval(df: DataFrame, d_label, wrt_label, accum=None):
    &#34;&#34;&#34;Compute an interval (std. dev) of d_label column with
    respect to pertubations in the wrt_label column
    &#34;&#34;&#34;
    if accum is None:
        accum = [&#39;std&#39;]
    df = df.astype({wrt_label: str})
    return df[[wrt_label, d_label]].groupby(wrt_label).agg(accum)


def perturbation_stats(df: DataFrame, *groups: str, wrt_col: str = &#39;out&#39;,
                       func=None):
    &#34;&#34;&#34;Compute statistics for wrt_col in df, conditional on groups
    &#34;&#34;&#34;
    if func is None:
        func = [&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;]
    groups = list(groups)
    df = df.groupby(groups).agg(func)[wrt_col]
    df.reset_index(inplace=True)
    return df.sort_values(groups[0])


def to_tuple(lists: list):
    &#34;&#34;&#34;Convert from lists to unpacked  tuple
    Ex. [[x1, y1], [x2, y2], [x3, y3]] -&gt; ([x1, x2, x3], [y1, y2, y3])
    Ex. [[x1, y1]] -&gt; ([x1], [y1])
    Ex. [m1, m2, m3] -&gt; [m1, m2, m3]
    Allows us to write X, y = ([x1, x2, x3], [y1, y2, y3])
    &#34;&#34;&#34;
    n_mods = len(lists)
    if n_mods &lt;= 1:
        return lists
    if not type(lists[0]) == list:
        return lists
    n_tup = len(lists[0])
    tup = [[] for _ in range(n_tup)]
    for i in range(n_mods):
        for j in range(n_tup):
            tup[j].append(lists[i][j])
    return tuple(tup)


def to_list(tup: tuple):
    &#34;&#34;&#34;Convert from tuple to packed list
    Ex. ([x1, x2, x3], [y1, y2, y3]) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
    Ex. ([x1], [y1]) -&gt; [[x1, y1]]
    Ex. ([x1, x2, x3]) -&gt; [[x1], [x2], [x3]]
    Ex. (x1) -&gt; [[x1]]
    Ex. (x1, y1) -&gt; [[x1, y1]]
    Ex. (x1, x2, x3, y1, y2, y3) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
    Ex. (x1, x2, x3, y1, y2) -&gt; Error
    Allows us to call function with arguments in a loop
    &#34;&#34;&#34;
    n_tup = len(tup)
    if n_tup == 0:
        return []
    elif not isinstance(tup[0], list):
        # the first element is data
        if n_tup == 1:
            return list(tup)
        if n_tup % 2 != 0:
            raise ValueError(&#39;Don\&#39;t know how to handle uneven number of args &#39;
                             &#39;without a list. Please wrap your args in a list.&#39;)
        # assume first half of args is input and second half is outcome
        return [list(el) for el in zip(tup[:(n_tup // 2)], tup[(n_tup // 2):])]
    elif n_tup == 1:
        return [[x] for x in tup[0]]
    n_mods = len(tup[0])
    lists_packed = [[] for _ in range(n_mods)]
    for i in range(n_mods):
        for j in range(n_tup):
            lists_packed[i].append(tup[j][i])
    return lists_packed


def sep_dicts(d: dict, n_out: int = 1, keys=None):
    &#34;&#34;&#34;converts dictionary with value being saved as an iterable into multiple dictionaries
    Assumes every value has same length n_out

    Params
    ------
    d: {k1: (x1, y1), k2: (x2, y2), ...,  &#39;__prev__&#39;: p}
    n_out: the number of dictionaries to separate d into

    Returns
    -------
    sep_dicts: [{k1: x1, k2: x2, ..., &#39;__prev__&#39;: p}, {k1: y1, k2: y2, &#39;__prev__&#39;: p}]
    &#34;&#34;&#34;
    if keys is None:
        keys = []
    if len(keys) &gt; 0 and len(keys) != n_out:
        raise ValueError(f&#39;keys should be empty or have length n_out={n_out}&#39;)
    # empty dict -- return empty dict
    if n_out &lt;= 1:
        return d
    else:
        # try separating dict into multiple dicts
        sep_dicts_id = str(uuid4())  # w/ high prob, uuid4 is unique
        sep_dicts_list = [dict() for _ in range(n_out)]
        for key, value in d.items():
            if key != PREV_KEY:
                for i in range(n_out):
                    # assumes the correct sub-key for item i is in the i-th position
                    if len(keys) == 0:
                        new_key = (key[i],) + key[n_out:]
                    else:
                        new_sub = Subkey(value=keys[i], origin=key[-1].origin + &#39;-&#39; + str(i))
                        new_key = (new_sub,) + key
                    new_key[-1]._sep_dicts_id = sep_dicts_id
                    if isinstance(value, VfuncPromise):
                        # return a promise to get the value at index i of the
                        # original promise
                        value_i = VfuncPromise(lambda v, x: v[x], value, i)
                    else:
                        value_i = value[i]
                    sep_dicts_list[i][new_key] = value_i

        return sep_dicts_list


def combine_keys(left_key, right_key):
    if len(left_key) &lt; len(right_key):
        match_key = left_key
        compare_key = right_key
    else:
        match_key = right_key
        compare_key = left_key
    match_subkeys = [subkey for subkey in match_key if subkey.is_matching()]
    if len(match_subkeys) &gt; 0:
        matched_subkeys = []
        for subkey in match_subkeys:
            for c_subkey in compare_key:
                if subkey.matches(c_subkey):
                    matched_subkeys.append(subkey)
                    break
                elif subkey.mismatches(c_subkey):
                    # subkeys with same origin but different values are rejected
                    return ()
        if len(matched_subkeys) &gt; 0:
            # always filter on right key
            filtered_key = tuple([subkey for subkey in right_key if subkey not in matched_subkeys])
            combined_key = left_key + filtered_key
            return combined_key
        else:
            return left_key + right_key
    else:
        return left_key + right_key


def combine_dicts(*args: dict, base_case=True):
    &#34;&#34;&#34;Combines any number of dictionaries into a single dictionary. Dictionaries
    are combined left to right, matching on the subkeys of the arg that has
    fewer matching requirements.
    &#34;&#34;&#34;
    n_args = len(args)
    combined_dict = {}
    if n_args == 0:
        return combined_dict
    elif n_args == 1:
        for k in args[0]:
            # wrap the dict values in tuples; this is helpful so that when we
            # pass the values to a module fun in we can just use * expansion
            if k != PREV_KEY:
                combined_dict[k] = (args[0][k],)
            else:
                combined_dict[k] = args[0][k]
        return combined_dict
    elif n_args == 2:
        for k0 in args[0]:
            for k1 in args[1]:

                if k0 == PREV_KEY or k1 == PREV_KEY:
                    continue

                combined_key = combine_keys(k0, k1)

                if len(combined_key) &gt; 0:
                    if base_case:
                        combined_dict[combined_key] = (args[0][k0], args[1][k1])
                    else:
                        combined_dict[combined_key] = args[0][k0] + (args[1][k1],)

        return combined_dict
    else:
        # combine the first two dicts and call recursively with remaining args
        return combine_dicts(combine_dicts(args[0], args[1]), *args[2:], base_case=False)


def apply_modules(modules: dict, data_dict: dict, lazy: bool = False):
    out_dict = {}
    for mod_k in modules:
        if len(data_dict) == 0:
            func = deepcopy(modules[mod_k])
            if lazy:
                out_dict[mod_k] = VfuncPromise(func)
            else:
                out_dict[mod_k] = func()
        for data_k in data_dict:
            if mod_k == PREV_KEY or data_k == PREV_KEY:
                continue

            combined_key = combine_keys(data_k, mod_k)

            if len(combined_key) &gt; 0:
                func = deepcopy(modules[mod_k])
                if lazy:
                    # return a promise
                    out_dict[combined_key] = VfuncPromise(func, *data_dict[data_k])
                else:
                    data_list = list(data_dict[data_k])
                    for i, data in enumerate(data_list):
                        if isinstance(data, VfuncPromise):
                            data_list[i] = data()
                    out_dict[combined_key] = func(*data_list)

    return out_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vflow.convert.apply_modules"><code class="name flex">
<span>def <span class="ident">apply_modules</span></span>(<span>modules: dict, data_dict: dict, lazy: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_modules(modules: dict, data_dict: dict, lazy: bool = False):
    out_dict = {}
    for mod_k in modules:
        if len(data_dict) == 0:
            func = deepcopy(modules[mod_k])
            if lazy:
                out_dict[mod_k] = VfuncPromise(func)
            else:
                out_dict[mod_k] = func()
        for data_k in data_dict:
            if mod_k == PREV_KEY or data_k == PREV_KEY:
                continue

            combined_key = combine_keys(data_k, mod_k)

            if len(combined_key) &gt; 0:
                func = deepcopy(modules[mod_k])
                if lazy:
                    # return a promise
                    out_dict[combined_key] = VfuncPromise(func, *data_dict[data_k])
                else:
                    data_list = list(data_dict[data_k])
                    for i, data in enumerate(data_list):
                        if isinstance(data, VfuncPromise):
                            data_list[i] = data()
                    out_dict[combined_key] = func(*data_list)

    return out_dict</code></pre>
</details>
</dd>
<dt id="vflow.convert.combine_dicts"><code class="name flex">
<span>def <span class="ident">combine_dicts</span></span>(<span>*args: dict, base_case=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Combines any number of dictionaries into a single dictionary. Dictionaries
are combined left to right, matching on the subkeys of the arg that has
fewer matching requirements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_dicts(*args: dict, base_case=True):
    &#34;&#34;&#34;Combines any number of dictionaries into a single dictionary. Dictionaries
    are combined left to right, matching on the subkeys of the arg that has
    fewer matching requirements.
    &#34;&#34;&#34;
    n_args = len(args)
    combined_dict = {}
    if n_args == 0:
        return combined_dict
    elif n_args == 1:
        for k in args[0]:
            # wrap the dict values in tuples; this is helpful so that when we
            # pass the values to a module fun in we can just use * expansion
            if k != PREV_KEY:
                combined_dict[k] = (args[0][k],)
            else:
                combined_dict[k] = args[0][k]
        return combined_dict
    elif n_args == 2:
        for k0 in args[0]:
            for k1 in args[1]:

                if k0 == PREV_KEY or k1 == PREV_KEY:
                    continue

                combined_key = combine_keys(k0, k1)

                if len(combined_key) &gt; 0:
                    if base_case:
                        combined_dict[combined_key] = (args[0][k0], args[1][k1])
                    else:
                        combined_dict[combined_key] = args[0][k0] + (args[1][k1],)

        return combined_dict
    else:
        # combine the first two dicts and call recursively with remaining args
        return combine_dicts(combine_dicts(args[0], args[1]), *args[2:], base_case=False)</code></pre>
</details>
</dd>
<dt id="vflow.convert.combine_keys"><code class="name flex">
<span>def <span class="ident">combine_keys</span></span>(<span>left_key, right_key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_keys(left_key, right_key):
    if len(left_key) &lt; len(right_key):
        match_key = left_key
        compare_key = right_key
    else:
        match_key = right_key
        compare_key = left_key
    match_subkeys = [subkey for subkey in match_key if subkey.is_matching()]
    if len(match_subkeys) &gt; 0:
        matched_subkeys = []
        for subkey in match_subkeys:
            for c_subkey in compare_key:
                if subkey.matches(c_subkey):
                    matched_subkeys.append(subkey)
                    break
                elif subkey.mismatches(c_subkey):
                    # subkeys with same origin but different values are rejected
                    return ()
        if len(matched_subkeys) &gt; 0:
            # always filter on right key
            filtered_key = tuple([subkey for subkey in right_key if subkey not in matched_subkeys])
            combined_key = left_key + filtered_key
            return combined_key
        else:
            return left_key + right_key
    else:
        return left_key + right_key</code></pre>
</details>
</dd>
<dt id="vflow.convert.compute_interval"><code class="name flex">
<span>def <span class="ident">compute_interval</span></span>(<span>df: pandas.core.frame.DataFrame, d_label, wrt_label, accum=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an interval (std. dev) of d_label column with
respect to pertubations in the wrt_label column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_interval(df: DataFrame, d_label, wrt_label, accum=None):
    &#34;&#34;&#34;Compute an interval (std. dev) of d_label column with
    respect to pertubations in the wrt_label column
    &#34;&#34;&#34;
    if accum is None:
        accum = [&#39;std&#39;]
    df = df.astype({wrt_label: str})
    return df[[wrt_label, d_label]].groupby(wrt_label).agg(accum)</code></pre>
</details>
</dd>
<dt id="vflow.convert.dict_to_df"><code class="name flex">
<span>def <span class="ident">dict_to_df</span></span>(<span>d: dict, param_key=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a dictionary with tuple keys
into a pandas DataFrame, optionally seperating
parameters in param_key if not None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_to_df(d: dict, param_key=None):
    &#34;&#34;&#34;Converts a dictionary with tuple keys
    into a pandas DataFrame, optionally seperating
    parameters in param_key if not None
    &#34;&#34;&#34;
    d_copy = {tuple([sk.value for sk in k]): d[k] for k in d if k != PREV_KEY}
    df = pd.Series(d_copy).reset_index()
    if len(d_copy.keys()) &gt; 0:
        key_list = list(d.keys())
        subkey_list = key_list[0] if key_list[0] != PREV_KEY else key_list[1]
        cols = [sk.origin for sk in subkey_list] + [&#39;out&#39;]
        # set each init col to init-{next_module_set}
        cols = [c if c != &#39;init&#39; else init_step(idx, cols) for idx, c in enumerate(cols)]
        df.set_axis(cols, axis=1, inplace=True)
        if param_key:
            df = df.join(pd.DataFrame(df[param_key].tolist()))
    return df</code></pre>
</details>
</dd>
<dt id="vflow.convert.init_args"><code class="name flex">
<span>def <span class="ident">init_args</span></span>(<span>args_tuple: Union[tuple, list], names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>converts tuple of arguments to a list of dicts
Params</p>
<hr>
<p>names: optional, list-like
gives names for each of the arguments in the tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_args(args_tuple: Union[tuple, list], names=None):
    &#34;&#34;&#34; converts tuple of arguments to a list of dicts
    Params
    ------
    names: optional, list-like
        gives names for each of the arguments in the tuple
    &#34;&#34;&#34;
    if names is None:
        names = [&#39;start&#39;] * len(args_tuple)
    else:
        assert len(names) == len(args_tuple), &#39;names should be same length as args_tuple&#39;

    output_dicts = []
    for (i, ele) in enumerate(args_tuple):
        output_dicts.append({
            (Subkey(names[i], &#39;init&#39;),): args_tuple[i],
            PREV_KEY: (&#39;init&#39;,),
        })
    return output_dicts</code></pre>
</details>
</dd>
<dt id="vflow.convert.init_step"><code class="name flex">
<span>def <span class="ident">init_step</span></span>(<span>idx, cols)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_step(idx, cols):
    for i in range(idx, len(cols)):
        if cols[i] != &#39;init&#39;:
            return &#39;init-&#39; + cols[i]</code></pre>
</details>
</dd>
<dt id="vflow.convert.perturbation_stats"><code class="name flex">
<span>def <span class="ident">perturbation_stats</span></span>(<span>df: pandas.core.frame.DataFrame, *groups: str, wrt_col: str = 'out', func=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute statistics for wrt_col in df, conditional on groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perturbation_stats(df: DataFrame, *groups: str, wrt_col: str = &#39;out&#39;,
                       func=None):
    &#34;&#34;&#34;Compute statistics for wrt_col in df, conditional on groups
    &#34;&#34;&#34;
    if func is None:
        func = [&#39;count&#39;, &#39;mean&#39;, &#39;std&#39;]
    groups = list(groups)
    df = df.groupby(groups).agg(func)[wrt_col]
    df.reset_index(inplace=True)
    return df.sort_values(groups[0])</code></pre>
</details>
</dd>
<dt id="vflow.convert.s"><code class="name flex">
<span>def <span class="ident">s</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets shape of a list/tuple/ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s(x):
    &#34;&#34;&#34;Gets shape of a list/tuple/ndarray
    &#34;&#34;&#34;
    if type(x) in [list, tuple]:
        return len(x)
    else:
        return x.shape</code></pre>
</details>
</dd>
<dt id="vflow.convert.sep_dicts"><code class="name flex">
<span>def <span class="ident">sep_dicts</span></span>(<span>d: dict, n_out: int = 1, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>converts dictionary with value being saved as an iterable into multiple dictionaries
Assumes every value has same length n_out</p>
<h2 id="params">Params</h2>
<p>d: {k1: (x1, y1), k2: (x2, y2), &hellip;,
'<strong>prev</strong>': p}
n_out: the number of dictionaries to separate d into</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sep_dicts</code></strong> :&ensp;<code>[{k1: x1, k2: x2, ..., '__prev__': p}, {k1: y1, k2: y2, '__prev__': p}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sep_dicts(d: dict, n_out: int = 1, keys=None):
    &#34;&#34;&#34;converts dictionary with value being saved as an iterable into multiple dictionaries
    Assumes every value has same length n_out

    Params
    ------
    d: {k1: (x1, y1), k2: (x2, y2), ...,  &#39;__prev__&#39;: p}
    n_out: the number of dictionaries to separate d into

    Returns
    -------
    sep_dicts: [{k1: x1, k2: x2, ..., &#39;__prev__&#39;: p}, {k1: y1, k2: y2, &#39;__prev__&#39;: p}]
    &#34;&#34;&#34;
    if keys is None:
        keys = []
    if len(keys) &gt; 0 and len(keys) != n_out:
        raise ValueError(f&#39;keys should be empty or have length n_out={n_out}&#39;)
    # empty dict -- return empty dict
    if n_out &lt;= 1:
        return d
    else:
        # try separating dict into multiple dicts
        sep_dicts_id = str(uuid4())  # w/ high prob, uuid4 is unique
        sep_dicts_list = [dict() for _ in range(n_out)]
        for key, value in d.items():
            if key != PREV_KEY:
                for i in range(n_out):
                    # assumes the correct sub-key for item i is in the i-th position
                    if len(keys) == 0:
                        new_key = (key[i],) + key[n_out:]
                    else:
                        new_sub = Subkey(value=keys[i], origin=key[-1].origin + &#39;-&#39; + str(i))
                        new_key = (new_sub,) + key
                    new_key[-1]._sep_dicts_id = sep_dicts_id
                    if isinstance(value, VfuncPromise):
                        # return a promise to get the value at index i of the
                        # original promise
                        value_i = VfuncPromise(lambda v, x: v[x], value, i)
                    else:
                        value_i = value[i]
                    sep_dicts_list[i][new_key] = value_i

        return sep_dicts_list</code></pre>
</details>
</dd>
<dt id="vflow.convert.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>tup: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from tuple to packed list
Ex. ([x1, x2, x3], [y1, y2, y3]) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
Ex. ([x1], [y1]) -&gt; [[x1, y1]]
Ex. ([x1, x2, x3]) -&gt; [[x1], [x2], [x3]]
Ex. (x1) -&gt; [[x1]]
Ex. (x1, y1) -&gt; [[x1, y1]]
Ex. (x1, x2, x3, y1, y2, y3) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
Ex. (x1, x2, x3, y1, y2) -&gt; Error
Allows us to call function with arguments in a loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(tup: tuple):
    &#34;&#34;&#34;Convert from tuple to packed list
    Ex. ([x1, x2, x3], [y1, y2, y3]) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
    Ex. ([x1], [y1]) -&gt; [[x1, y1]]
    Ex. ([x1, x2, x3]) -&gt; [[x1], [x2], [x3]]
    Ex. (x1) -&gt; [[x1]]
    Ex. (x1, y1) -&gt; [[x1, y1]]
    Ex. (x1, x2, x3, y1, y2, y3) -&gt; [[x1, y1], [x2, y2], [x3, y3]]
    Ex. (x1, x2, x3, y1, y2) -&gt; Error
    Allows us to call function with arguments in a loop
    &#34;&#34;&#34;
    n_tup = len(tup)
    if n_tup == 0:
        return []
    elif not isinstance(tup[0], list):
        # the first element is data
        if n_tup == 1:
            return list(tup)
        if n_tup % 2 != 0:
            raise ValueError(&#39;Don\&#39;t know how to handle uneven number of args &#39;
                             &#39;without a list. Please wrap your args in a list.&#39;)
        # assume first half of args is input and second half is outcome
        return [list(el) for el in zip(tup[:(n_tup // 2)], tup[(n_tup // 2):])]
    elif n_tup == 1:
        return [[x] for x in tup[0]]
    n_mods = len(tup[0])
    lists_packed = [[] for _ in range(n_mods)]
    for i in range(n_mods):
        for j in range(n_tup):
            lists_packed[i].append(tup[j][i])
    return lists_packed</code></pre>
</details>
</dd>
<dt id="vflow.convert.to_tuple"><code class="name flex">
<span>def <span class="ident">to_tuple</span></span>(<span>lists: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from lists to unpacked
tuple
Ex. [[x1, y1], [x2, y2], [x3, y3]] -&gt; ([x1, x2, x3], [y1, y2, y3])
Ex. [[x1, y1]] -&gt; ([x1], [y1])
Ex. [m1, m2, m3] -&gt; [m1, m2, m3]
Allows us to write X, y = ([x1, x2, x3], [y1, y2, y3])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_tuple(lists: list):
    &#34;&#34;&#34;Convert from lists to unpacked  tuple
    Ex. [[x1, y1], [x2, y2], [x3, y3]] -&gt; ([x1, x2, x3], [y1, y2, y3])
    Ex. [[x1, y1]] -&gt; ([x1], [y1])
    Ex. [m1, m2, m3] -&gt; [m1, m2, m3]
    Allows us to write X, y = ([x1, x2, x3], [y1, y2, y3])
    &#34;&#34;&#34;
    n_mods = len(lists)
    if n_mods &lt;= 1:
        return lists
    if not type(lists[0]) == list:
        return lists
    n_tup = len(lists[0])
    tup = [[] for _ in range(n_tup)]
    for i in range(n_mods):
        for j in range(n_tup):
            tup[j].append(lists[i][j])
    return tuple(tup)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vflow" href="index.html">vflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="vflow.convert.apply_modules" href="#vflow.convert.apply_modules">apply_modules</a></code></li>
<li><code><a title="vflow.convert.combine_dicts" href="#vflow.convert.combine_dicts">combine_dicts</a></code></li>
<li><code><a title="vflow.convert.combine_keys" href="#vflow.convert.combine_keys">combine_keys</a></code></li>
<li><code><a title="vflow.convert.compute_interval" href="#vflow.convert.compute_interval">compute_interval</a></code></li>
<li><code><a title="vflow.convert.dict_to_df" href="#vflow.convert.dict_to_df">dict_to_df</a></code></li>
<li><code><a title="vflow.convert.init_args" href="#vflow.convert.init_args">init_args</a></code></li>
<li><code><a title="vflow.convert.init_step" href="#vflow.convert.init_step">init_step</a></code></li>
<li><code><a title="vflow.convert.perturbation_stats" href="#vflow.convert.perturbation_stats">perturbation_stats</a></code></li>
<li><code><a title="vflow.convert.s" href="#vflow.convert.s">s</a></code></li>
<li><code><a title="vflow.convert.sep_dicts" href="#vflow.convert.sep_dicts">sep_dicts</a></code></li>
<li><code><a title="vflow.convert.to_list" href="#vflow.convert.to_list">to_list</a></code></li>
<li><code><a title="vflow.convert.to_tuple" href="#vflow.convert.to_tuple">to_tuple</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>